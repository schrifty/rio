#!/usr/bin/env ruby
require File.expand_path(File.dirname(__FILE__) + "/../config/environment")

#TENANT_NAME = "Tesla Motors"
AGENT_COUNT = 5
CUSTOMER_COUNT = 20

MUTEX = Mutex.new
#AR_MUTEX = Mutex.new

def mlog(str)
  MUTEX.synchronize do
    puts "[#{Thread.current["id"]}] - #{Time.now.strftime('%H:%M:%S')}: #{str}"
  end
end

def safely
  #AR_MUTEX.synchronize do
    ActiveRecord::Base.connection_pool.with_connection do | connection |
      #mlog connection.is_read_only?
      yield
    end
  #end
end

def run_customer(tenant, customer)
  begin
    sleep(rand(60))
    mlog "Customer ##{customer.id} is alive!"
    conversation = nil
    while true do
      unless conversation
        conversation = safely { FactoryGirl.create(:conversation, :tenant => tenant, :customer => customer, :resolved => false, :engaged_agent => nil) }
        mlog "Customer ##{customer.id} opening ticket ##{conversation.id}"
        safely { FactoryGirl.create(:message, :tenant => tenant, :conversation => conversation, :agent => nil) }
        sleep(20 + rand(20))
      end

      # if the agent responded...
      conversation = safely { Conversation.find(conversation.id) }
      last_message = safely { conversation.last_message }
      if last_message.agent_id

        # 5% chance this is the last message in the conversation and it's resolved
        if (rand(10) == 1)
          mlog "Customer ##{customer.id} is resolving conversation ##{conversation.id}"
          safely { FactoryGirl.create(:message, :tenant => tenant, :conversation => conversation, :agent => nil, :text => 'Thank you!') }
          safely { conversation.update_attributes!(:resolved => 1) }
          conversation = nil
          sleep(10 + rand(20))
        else
          mlog "Customer ##{customer.id} is replying to conversation ##{conversation.id}"
          safely { FactoryGirl.create(:message, :tenant => tenant, :conversation => conversation, :agent => nil) }
          sleep(10 + rand(20))
        end
      end
      ActiveRecord::Base.connection_pool.clear_stale_cached_connections!
    end
  rescue Exception => e
    mlog ([e.message] + e.backtrace).join("\n")
  end
end

def run_agent(tenant, agent)
  begin
    sleep(rand(60))
    mlog "Agent ##{agent.id} is alive!"
    while true do
      if agent.available == 1
        mlog "Agent ##{agent.id} is checking his inbox!"
        conversation = safely { Conversation.by_tenant(tenant).agent_inbox(agent).first }
        if conversation
          mlog "Agent ##{agent.id} is responding to conversation ##{conversation.id}"
          safely { FactoryGirl.create(:message, :tenant => tenant, :conversation => conversation, :agent => agent) }
        end
        sleep(15 + rand(20))
        if rand(20) == 1
          mlog "Agent ##{agent.id} has gone offline"
          safely { agent.update_attributes!(:available => 0) }
          sleep(15 + rand(20))
        end
      else
        if rand(20) == 1
          mlog "Agent ##{agent.id} has come online"
          safely { agent.update_attributes!(:available => 1) }
        end
        sleep(10 + rand(20))
      end
      ActiveRecord::Base.connection_pool.clear_stale_cached_connections!
    end
  rescue Exception => e
    mlog ([e.message] + e.backtrace).join("\n")
  end
end

mlog "Creating #{AGENT_COUNT} agents and #{CUSTOMER_COUNT} customers"
#tenant = FactoryGirl.create(:tenant)
tenant = Tenant.find(119)
agent_email = 'vernice.treutel@example.net'
Message.destroy_all("tenant_id = '#{tenant.id}'")
Conversation.destroy_all("tenant_id = '#{tenant.id}'")
Customer.destroy_all("tenant_id = '#{tenant.id}'")
Agent.destroy_all("tenant_id = '#{tenant.id}' AND email <> '#{agent_email}'")

mlog "TENANT: #{tenant.id}"
agents = (1..AGENT_COUNT).collect { |n|
  cont = true
  girl = nil
  while cont
    begin
      girl = FactoryGirl.create(:agent, :tenant => tenant, :available => true, :password => 'cheyenne')
      cont = false
    rescue Exception => e
      mlog ([e.message] + e.backtrace).join('\n')
    end
  end
  girl
}
customers = (1..CUSTOMER_COUNT).collect { |n| FactoryGirl.create(:customer, :tenant => tenant) }

mlog "Spinning up agent and customer threads"
i = 0
customer_threads = customers.collect { |customer|
  t = Thread.new { run_customer(tenant, customer) }
  i = i + 1
  t["id"] = i
  t
}

agent_threads = agents.collect { |agent|
  t = Thread.new { run_agent(tenant, agent) }
  i = i + 1
  t["id"] = i
  t
}

(customer_threads + agent_threads).each { |t| t.join }

#def sleepy(n)
#  mlog "Thread ##{n}: Alive"
#  sleep(10)
#  mlog "Thread ##{n}: Woken"
#end
#
#threads = (1..100).collect{|n| Thread.new { sleepy(n) } }
#threads.each {|t| t.join }